#pragma kernel CSMain

struct Quoid
{
	float3 position;
	float3 direction;
	float noise_offset;
};

struct Vertex
{
    float3 position;
    float2 uv;
};

StructuredBuffer<Quoid> quoidBuffer;
RWStructuredBuffer<Vertex> vertexBuffer;

uint frameGridSizeX, frameGridSizeY;
int quoidCount;
float quadHalfSize;

[numthreads(8,8,1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
    if(id.x >= frameGridSizeX) return;
    if(id.y >= frameGridSizeY) return;

    int quoidIndex = (int)id.x + (int)id.y * frameGridSizeX;
    
    Quoid p = quoidBuffer[quoidIndex];

	int vertexIndex = quoidIndex * 6;

	// Triangle 1 : bottom-left, top-left, top-right
	vertexBuffer[vertexIndex].position.x = p.position.x - quadHalfSize;
	vertexBuffer[vertexIndex].position.y = p.position.y;
	vertexBuffer[vertexIndex].position.z = p.position.z - quadHalfSize;

	vertexBuffer[vertexIndex + 1].position.x = p.position.x - quadHalfSize;
	vertexBuffer[vertexIndex + 1].position.y =  p.position.y;
	vertexBuffer[vertexIndex + 1].position.z = p.position.z + quadHalfSize;

	vertexBuffer[vertexIndex + 2].position.x = p.position.x + quadHalfSize;
	vertexBuffer[vertexIndex + 2].position.y =  p.position.y;
	vertexBuffer[vertexIndex + 2].position.z = p.position.z + quadHalfSize;
 
	// Triangle 2 : bottom-left, top-right, bottom-right
	vertexBuffer[vertexIndex + 3].position.x = p.position.x - quadHalfSize;
	vertexBuffer[vertexIndex + 3].position.y = p.position.y;
	vertexBuffer[vertexIndex + 3].position.z = p.position.z - quadHalfSize;

	vertexBuffer[vertexIndex + 4].position.x = p.position.x + quadHalfSize;
	vertexBuffer[vertexIndex + 4].position.y =  p.position.y;
	vertexBuffer[vertexIndex + 4].position.z = p.position.z + quadHalfSize;

	vertexBuffer[vertexIndex + 5].position.x = p.position.x + quadHalfSize;
	vertexBuffer[vertexIndex + 5].position.y =  p.position.y;
	vertexBuffer[vertexIndex + 5].position.z = p.position.z - quadHalfSize;
}