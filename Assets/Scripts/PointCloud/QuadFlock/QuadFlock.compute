#pragma kernel CSMain

float hash(float n) {
	return frac(sin(n)*43758.5453);
}

float noise1(float3 x) {
	float3 p = floor(x);
	float3 f = frac(x);

	f = f * f * (3.0 - 2.0 * f);
	float n = p.x + p.y * 57.0 + p.z * 113.0;

	return lerp(
				lerp(
					lerp( 
						hash(n + 0.0), 
						hash(n + 1.0), 
						f.x
					),
					lerp( 
						hash(n + 57.0), 
						hash(n + 58.0), 
						f.x
					), 
					f.y
				),
				lerp(
					lerp( 
						hash(n + 113.0), 
						hash(n + 114.0), 
						f.x
					),
					lerp( 
						hash(n + 170.0), 
						hash(n + 171.0), 
						f.x
					), 
					f.y
				), 
				f.z
			);
}

struct Quoid
{
	float3 position;
	float3 direction;
	float noise_offset;
};

RWStructuredBuffer<Quoid> quoidBuffer;

// static : config
uint frameGridSizeX, frameGridSizeY;
int quoidCount;
float quadHalfSize;

// static : flocking
float rotationSpeed;
float speed;
float speedVariation;
float3 flockPosition;
float neighbourDistance;

// dynamic
float time;
float deltaTime;

[numthreads(8,8,1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
    if(id.x >= frameGridSizeX) return;
    if(id.y >= frameGridSizeY) return;

    uint quoidIndex = id.x + id.y * frameGridSizeX;
    
    Quoid quoid = quoidBuffer[quoidIndex];

	float noise = clamp(noise1(time / 100.0 + quoid.noise_offset), -1, 1) * 2.0 - 1.0;
	float velocity = speed * (1.0 + noise * speedVariation);

	float3 quoid_pos = quoid.position;
	float3 quoid_dir = quoid.direction;

	float3 separation = 0;
	float3 alignment = 0;
	float3 cohesion = flockPosition;

	uint nearbyCount = 1; // Add self that is ignored in loop

	for (uint i = 0; i < (uint)quoidCount; i++) {
		if (i == quoidIndex) continue;
		
		float3 tempQuoid_position = quoidBuffer[i].position;

		float3 offset = quoid.position - tempQuoid_position;
		float dist = max(length(offset), 0.000001);
		
		if (dist < neighbourDistance)
		{
			separation += offset * (1.0 / dist - 1.0 / neighbourDistance);
			alignment += quoidBuffer[i].direction;
			cohesion += tempQuoid_position;

			nearbyCount += 1;
		}
	}

	float avg = 1.0 / nearbyCount;
	alignment *= avg;
	cohesion *= avg;
	cohesion = normalize(cohesion - quoid_pos);

	float3 direction = alignment + separation + cohesion;

	float prop = exp(-rotationSpeed * deltaTime); // This will be around 0.95
	quoid.direction = lerp((direction), normalize(quoid_dir), prop);

	quoid.position += quoid.direction * velocity * deltaTime;

	quoidBuffer[quoidIndex] = quoid;


	// int vertexIndex = quoidIndex * 6;

	// // Triangle 1 : bottom-left, top-left, top-right
	// vertexBuffer[vertexIndex].position.x = quoid.position.x - quadHalfSize;
	// vertexBuffer[vertexIndex].position.y = quoid.position.y;
	// vertexBuffer[vertexIndex].position.z = quoid.position.z - quadHalfSize;

	// vertexBuffer[vertexIndex + 1].position.x = quoid.position.x - quadHalfSize;
	// vertexBuffer[vertexIndex + 1].position.y =  quoid.position.y;
	// vertexBuffer[vertexIndex + 1].position.z = quoid.position.z + quadHalfSize;

	// vertexBuffer[vertexIndex + 2].position.x = quoid.position.x + quadHalfSize;
	// vertexBuffer[vertexIndex + 2].position.y =  quoid.position.y;
	// vertexBuffer[vertexIndex + 2].position.z = quoid.position.z + quadHalfSize;
 
	// // Triangle 2 : bottom-left, top-right, bottom-right
	// vertexBuffer[vertexIndex + 3].position.x = quoid.position.x - quadHalfSize;
	// vertexBuffer[vertexIndex + 3].position.y = quoid.position.y;
	// vertexBuffer[vertexIndex + 3].position.z = quoid.position.z - quadHalfSize;

	// vertexBuffer[vertexIndex + 4].position.x = quoid.position.x + quadHalfSize;
	// vertexBuffer[vertexIndex + 4].position.y =  quoid.position.y;
	// vertexBuffer[vertexIndex + 4].position.z = quoid.position.z + quadHalfSize;

	// vertexBuffer[vertexIndex + 5].position.x = quoid.position.x + quadHalfSize;
	// vertexBuffer[vertexIndex + 5].position.y =  quoid.position.y;
	// vertexBuffer[vertexIndex + 5].position.z = quoid.position.z - quadHalfSize;
}